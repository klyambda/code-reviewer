file_prompt = """
Цель: Проверить архитектуру и структуру. Выявить ошибки, предложить улучшения, указать шаги для исправления. Код на Python.
Вот список требований:
Гексагональная архитектура.  

Слой приложения: бизнес-логика, независимость от адаптеров через DI. Сложные области — сущности с инвариантами, маппинг на таблицы. Простые области — DTO. Межслойные данные только через DTO. Валидация: pydantic модели в сервисах. Ошибки описаны в этом слое.  

Слой адаптеров: интеграции, работа с БД (SQLAlchemy, naming_convention, env.py Alembic). Таблицы — snake_case, множественное число для сущностей и справочников, единственное для логов. Запросы через репозитории, данные возвращаются ORM-объектами или DTO. Веб-код: настройка, контроллеры, сериализация (Decimal → строка, datetime → ISO 8601, Enum → name/value). Обработка ошибок — трансформация для внешних компонентов.  

Слой композитов: сборка компонентов (БД, сервисы, HTTP API). DI для зависимостей.  

Настройки: через ENV, pydantic BaseSettings.  

Время: хранение в naive UTC (datetime), на фронт с тайм-зоной.  

Отчеты: допускаются тяжелые SQL-запросы, минимизация диалекто-зависимости. Прямой вызов репозиториев в контроллерах при отсутствии обработки ответа.
Результат анализа:
Указание ошибок (если есть).
Предложение улучшений по структуре (если есть).
Подтверждение, если всё корректно.
ПИШИ ТОЛЬКО НА РУССКОМ ЯЗЫКЕ."""


project_prompt = """
Цель: Проверить архитектуру и структуру. Выявить ошибки, предложить улучшения, указать шаги для исправления.
Вот список требований:
Гексагональная архитектура.  

Слой приложения: бизнес-логика, независимость от адаптеров через DI. Сложные области — сущности с инвариантами, маппинг на таблицы. Простые области — DTO. Межслойные данные только через DTO. Валидация: pydantic модели в сервисах. Ошибки описаны в этом слое.  

Слой адаптеров: интеграции, работа с БД (SQLAlchemy, naming_convention, env.py Alembic). Таблицы — snake_case, множественное число для сущностей и справочников, единственное для логов. Запросы через репозитории, данные возвращаются ORM-объектами или DTO. Веб-код: настройка, контроллеры, сериализация (Decimal → строка, datetime → ISO 8601, Enum → name/value). Обработка ошибок — трансформация для внешних компонентов.  

Слой композитов: сборка компонентов (БД, сервисы, HTTP API). DI для зависимостей.  

Настройки: через ENV, pydantic BaseSettings.  

Время: хранение в naive UTC (datetime), на фронт с тайм-зоной.  

Отчеты: допускаются тяжелые SQL-запросы, минимизация диалекто-зависимости. Прямой вызов репозиториев в контроллерах при отсутствии обработки ответа.
Результат анализа:
Указание ошибок (если есть).
Предложение улучшений по структуре (если есть).
Подтверждение, если всё корректно.
ПИШИ ТОЛЬКО НА РУССКОМ ЯЗЫКЕ.
"""


file_prompt_csharp = """
Цель: Проверить архитектуру и структуру. Выявить ошибки, предложить улучшения, указать шаги для исправления. Код на C#
Вот список требований:
правильно организованная структура проекта: нет ненужных зависимостей, отсутствуют ссылки на локальные файлы, корректно настроены NuGet-пакеты;
все используемые библиотеки должны быть безопасны и актуальны;
наличие комментариев к классам, методам и другим сущностям;
использование устаревших элементов (например, методов с атрибутом Obsolete);
отсутствие неиспользуемого или закомментированного кода, а также нерешенных TODO;
корректность логирования исключений, избегая дублирования сообщений;
правильность работы с LINQ и Entity Framework, включая корректное выполнение асинхронных операций;

Архитектура и дизайн
корректно ли зарегистрированы сервисы в IoC контейнере;
методы возвращают ожидаемые типы данных (например, пустые коллекции вместо null);
наличие проверок входных аргументов внутри методов;

Результат анализа:
Указание ошибок (если есть).
Предложение улучшений по структуре (если есть).
Подтверждение, если всё корректно.
ПИШИ ТОЛЬКО НА РУССКОМ ЯЗЫКЕ.
"""

file_prompt_ts = """
Цель: Проверить архитектуру и структуру. Выявить ошибки, предложить улучшения, указать шаги для исправления. Код на TypeScript
Вот список требований:
Имена должны передавать намерения программиста. Имя переменной, функции, класса должно отвечать на все главные вопросы: почему существует, что делает и как используется;
### Именование
- Проверь, что имена функций, классов, переменных и констант соответствуют стандартам.
  - **camelCase** для переменных и функций.
  - **PascalCase** для классов, интерфейсов и компонентов.
  - **UPPER_SNAKE_CASE** для констант.
В проектах ДОЛЖНЫ использоваться обычные функции вместо стрелочных;
Основной компонент приложения, точка входа.
API Содержит функции получение данных. ДОЛЖЕН содержать запросы API или подписки RabbitMQ;
Адаптеры используются для преобразования данных из одного формата в другой. Для каждого ответа
сервера ДОЛЖЕН использоваться свой адаптер. Для компонента, который использует массивы
объектов, объект в качестве атрибута props, ДОЛЖЕН создаваться адаптер;
Components Содержит компоненты приложения в предметной области UI.
Содержит компоненты приложения в предметной области UI.

Результат анализа:
Указание ошибок (если есть).
Предложение улучшений по структуре (если есть).
Подтверждение, если всё корректно.
ПИШИ ТОЛЬКО НА РУССКОМ ЯЗЫКЕ.
"""
